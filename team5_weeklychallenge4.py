# -*- coding: utf-8 -*-
"""Team5_weeklychallenge4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hdMTFcKsZZDKdnHrQdRRYqvizI2kRFw8
"""

import subprocess
import sys

def install(package):
    subprocess.check_call([sys.executable, "-m", "pip", "install", package])

# Install required packages
packages = ['dash', 'dash-bootstrap-components', 'plotly']
for package in packages:
    install(package)



import dash
from dash import dcc, html, Input, Output
import dash_bootstrap_components as dbc
import plotly.express as px
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Load the dataset
file_path = '/content/drive/MyDrive/Police_Bulk_Data_2014_20241027.csv'
df = pd.read_csv(file_path)

from google.colab import drive
drive.mount('/content/drive')

df.info()

# List of relevant columns based on your context
columns_of_interest = [
    'offensedate',
    'offensereporteddate',
    'offensedescription',
    'offensegender',
    'offenserace',
    'offensereportingarea',
    'offensecity',
    'offensestate',

]

# Calculate the number of missing values for each of these columns
missing_values = df[columns_of_interest].isnull().sum()

# Create a DataFrame to display the results
missing_values_df = pd.DataFrame({
    'Column': missing_values.index,
    'Missing Values': missing_values.values,
    'Percentage Missing': (missing_values.values / len(df)) * 100
})

# Sort by the number of missing values in descending order
missing_values_df = missing_values_df.sort_values(by='Missing Values', ascending=False)

# Display the results
print("Missing Values Summary for Selected Columns:")
print(missing_values_df)

#  Impute missing values with the mode
columns_to_impute = ['offensegender', 'offenserace', 'offensestate', 'offensecity', 'offensereportingarea']

# Loop through each column and impute missing values with the mode
for column in columns_to_impute:
    mode_value = df[column].mode()[0]  # Get the mode (most frequent value)
    df[column].fillna(mode_value, inplace=True)

# Check if missing values have been imputed
print("\nMissing Values After Imputation:")
print(df[columns_to_impute].isnull().sum())

df['offensedate'] = pd.to_datetime(df['offensedate'], errors='coerce')

# Drop rows with invalid or missing dates
df = df.dropna(subset=['offensedate'])
# Group by date to get the count of offenses per day
offenses_per_day = df['offensedate'].value_counts().sort_index()

# Plot a line plot using Seaborn
plt.figure(figsize=(14, 8))
sns.lineplot(x=offenses_per_day.index, y=offenses_per_day.values, color='red')

# Format the plot to look similar to your uploaded example
plt.title('Offenses Over Time')
plt.xlabel('Date')
plt.ylabel('Number of Offenses')
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd



# Bivariate Plot: Count Plot of offenses by gender and race
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x='offensegender', hue='offenserace', palette='Set2')
plt.title('Offenses by Gender and Race')
plt.xlabel('Gender')
plt.ylabel('Count of Offenses')
plt.xticks(rotation=45)
plt.legend(title='Race', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(axis='y')
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Convert relevant columns to numeric
df['offensereportingarea'] = pd.to_numeric(df['offensereportingarea'], errors='coerce')
df['offensepropertyattackcode'] = pd.to_numeric(df['offensepropertyattackcode'], errors='coerce')
df['offensezip'] = pd.to_numeric(df['offensezip'], errors='coerce')

# Drop rows with NaN values in the selected columns
df_cleaned = df.dropna(subset=['offensereportingarea', 'offensepropertyattackcode', 'offensezip'])

# Define the numerical columns for correlation
numeric_cols = ['offensereportingarea', 'offensepropertyattackcode', 'offensezip']

# Generate the heatmap
plt.figure(figsize=(10, 6))
sns.heatmap(df_cleaned[numeric_cols].corr(), annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('Correlation Heatmap of Numerical Features')
plt.show()

# Count the number of offenses by gender
gender_counts = df['offensegender'].value_counts()

# Plot a pie chart
plt.figure(figsize=(4, 4))
plt.pie(gender_counts, labels=gender_counts.index, autopct='%1.1f%%', startangle=90, colors=['#66c2a5', '#fc8d62'])
plt.title('Offenses by Gender')
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.show()

# Plot a histogram using Seaborn
plt.figure(figsize=(10, 6))
sns.histplot(data=df, x='offenserace', kde=False, palette='viridis', shrink=0.8)
plt.title('Distribution of Offenses by Race')
plt.xlabel('Race')
plt.ylabel('Number of Offenses')
plt.xticks(rotation=45)
plt.grid(axis='y')
plt.show()



import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objs as go
import numpy as np

# Load the data
@st.cache_data
def load_data():
    # Replace this with the actual path to your data
    df = pd.read_csv(file_path)
    df['offensedate'] = pd.to_datetime(df['offensedate'])
    return df

df = load_data()

# Set page config
st.set_page_config(page_title="Police Offenses Dashboard", layout="wide")

# Title
st.title("Police Offenses Dashboard")

# Filters
col1, col2 = st.columns(2)
with col1:
    start_date, end_date = st.date_input(
        "Select Date Range",
        [df['offensedate'].min(), df['offensedate'].max()],
        key='date_range'
    )

with col2:
    offense_type = st.multiselect(
        "Select Offense Type",
        options=df['offensedescription'].unique(),
        key='offense_type'
    )

distribution_variable = st.selectbox(
    "Select Variable for Distribution Plot",
    options=['offensestate', 'offenserace'],
    key='distribution_variable'
)

# Filter data
filtered_df = df[(df['offensedate'].dt.date >= start_date) &
                 (df['offensedate'].dt.date <= end_date)]

if offense_type:
    filtered_df = filtered_df[filtered_df['offensedescription'].isin(offense_type)]

# Charts
def create_trend_chart(data):
    trend_df = data.groupby(data['offensedate'].dt.date).size().reset_index(name='count')
    fig = px.line(
        trend_df,
        x='offensedate',
        y='count',
        title='Offenses Over Time',
        labels={'offensedate': 'Date', 'count': 'Number of Offenses'},
        template='plotly',
        line_shape='spline',
        color_discrete_sequence=['#FF6347']
    )
    return fig

def create_gender_pie(data):
    fig = px.pie(
        data,
        names='offensegender',
        title='Offenses by Gender',
        template='plotly',
        color_discrete_map={'M': '#3498DB', 'F': '#E74C3C', 'Withheld': '#2ECC71'}
    )
    return fig

def create_distribution_plot(data, variable):
    if variable == 'offensestate':
        top_states = data['offensestate'].value_counts().nlargest(3).index
        data_top_states = data[data['offensestate'].isin(top_states)]
        fig = px.histogram(
            data_top_states,
            x='offensestate',
            title='Top 3 States with the Most Offenses',
            labels={'offensestate': 'State', 'count': 'Number of Offenses'},
            template='plotly',
            color_discrete_sequence=['#8A2BE2']
        )
    else:
        fig = px.histogram(
            data,
            x=variable,
            title=f'Distribution of {variable.title()}',
            labels={variable: variable.title()},
            template='plotly',
            color_discrete_sequence=['#8A2BE2']
        )
    return fig

def create_gender_race_countplot(data):
    gender_race_counts = data.groupby(['offensegender', 'offenserace']).size().reset_index(name='count')
    fig = px.bar(
        gender_race_counts,
        x='offensegender',
        y='count',
        color='offenserace',
        title='Offenses by Gender and Race',
        labels={'offensegender': 'Gender', 'count': 'Count', 'offenserace': 'Race'},
        template='plotly',
        barmode='group'
    )
    return fig

def create_correlation_heatmap(data):
    numeric_cols = ['offensereportingarea', 'offensepropertyattackcode', 'offensezip']
    corr_matrix = data[numeric_cols].corr()
    fig = go.Figure(data=go.Heatmap(
        z=corr_matrix.values,
        x=corr_matrix.columns,
        y=corr_matrix.columns,
        text=np.round(corr_matrix.values, 2),
        texttemplate='%{text}',
        textfont={"size": 10},
        hoverongaps=False,
        colorscale='RdBu'
    ))
    fig.update_layout(
        title='Correlation Heatmap of Numerical Features',
        height=400
    )
    return fig

# Display charts
col1, col2 = st.columns(2)

with col1:
    st.plotly_chart(create_trend_chart(filtered_df), use_container_width=True)
    st.plotly_chart(create_gender_race_countplot(filtered_df), use_container_width=True)

with col2:
    st.plotly_chart(create_gender_pie(filtered_df), use_container_width=True)
    st.plotly_chart(create_distribution_plot(filtered_df, distribution_variable), use_container_width=True)

st.plotly_chart(create_correlation_heatmap(filtered_df), use_container_width=True)
